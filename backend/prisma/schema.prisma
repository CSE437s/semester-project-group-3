generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id              Int                  @id @default(autoincrement())
  email           String               @unique @db.VarChar(100)
  last_login      DateTime
  password_hashed String               @db.VarChar(255)
  time_created    DateTime             @default(now())
  username        String               @db.VarChar(25)
  workouts        Workout[]
  active          Boolean              @default(false)
  authcode        AuthCode?
  followers       Follow[]             @relation("UserFollowing")
  following       Follow[]             @relation("UserFollowers")
  saved_exercises UserSavedExercises[]
  scheduled_workouts        ScheduledWorkout[]
  posts          Post[]
  likes          Like[]
  workout_likes  WorkoutLike[]
}

model Post {
  id           Int       @id @default(autoincrement())
  createdAt    DateTime  @default(now())
  imageUrl     String?   // image is optional (url field will be used if we decide to move image storage to S3 or similar service)
  image        Bytes?    // image is optional
  caption      String?   // caption also optional, but we enforce on frontend that at least one of imageUrl or caption is present 
  userId       Int       
  user         User      @relation(fields: [userId], references: [id])
  likes        Like[]
}

model Like {
  id         Int   @id @default(autoincrement())
  userId     Int   
  postId     Int  
  user       User  @relation(fields: [userId], references: [id])
  post       Post  @relation(fields: [postId], references: [id])
  @@unique([userId, postId]) // prevents duplicate likes from the same user for the same post
}

model UserSavedExercises {
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId     Int
  exercise   Exercise @relation(fields: [exerciseId], references: [id], onDelete: Cascade)
  exerciseId Int
  saved      DateTime

  @@id([userId, exerciseId])
}

model Follow {
  followerId  Int
  followingId Int
  createdAt   DateTime @default(now())
  follower    User     @relation("UserFollowers", fields: [followerId], references: [id])
  following   User     @relation("UserFollowing", fields: [followingId], references: [id])

  @@id([followerId, followingId])
}

model AuthCode {
  id          Int      @id @default(autoincrement())
  user_id     Int      @unique
  value       Int
  user        User     @relation(fields: [user_id], references: [id], onDelete: Cascade)
  valid_until DateTime
}

model Workout {
  id           Int        @id @default(autoincrement())
  user_id      Int
  name         String     @db.VarChar(255)
  difficulty   Difficulty
  description  String
  time_created DateTime   @default(now())
  // muscles      Muscle[]
  //Idea: autogenerate the muscle groups hit and have them displayed with the workout in order of intensity for that muscle group
  //fading in color as it goes to less-worked muscles
  routines     Routine[]
  tags         Tag[]
  user         User       @relation(fields: [user_id], references: [id], onDelete: Cascade)
  scheduled_workouts ScheduledWorkout[]
  likes       WorkoutLike[]
}

// have to define a seaparate model for workout likes (probably could have set this up smarter, oops)
model WorkoutLike {
  id         Int      @id @default(autoincrement())
  userId     Int   
  workoutId  Int  
  user       User    @relation(fields: [userId], references: [id])
  workout    Workout @relation(fields: [workoutId], references: [id])
  @@unique([userId, workoutId]) // prevents duplicate likes from the same user for the same workout
}

//Create copies of workout, routines, sets
//Change api endpoints to keep changes consistent for all uncompleted scheduledworkouts
model ScheduledWorkout {
  id Int @id @default(autoincrement())
  date DateTime @db.Date
  user         User       @relation(fields: [user_id], references: [id], onDelete: Cascade)
  user_id      Int
  workout Workout? @relation(fields: [workout_id], references: [id])
  workout_id Int?
  completion CompletionStatus @default(scheduled)
  routines ScheduledRoutine[]
  name         String     @db.VarChar(255)
  difficulty   Difficulty
  description  String
}

model Routine {
  id          Int          @id @default(autoincrement())
  exercise_id Int
  rest        Int @default(60)
  workout_id  Int
  exercise    Exercise     @relation(fields: [exercise_id], references: [id], onDelete: Cascade)
  workout     Workout      @relation(fields: [workout_id], references: [id], onDelete: Cascade)
  sets        DefaultSet[]
}

model ScheduledRoutine {
  id Int @id @default(autoincrement())
  workout ScheduledWorkout @relation(fields: [workout_id], references: [id], onDelete: Cascade)
  exercise_id Int
  rest        Int @default(60)
  workout_id  Int
  exercise    Exercise     @relation(fields: [exercise_id], references: [id], onDelete: Cascade)
  sets ScheduledSet[]
}

model DefaultSet {
  id           Int          @id @default(autoincrement())
  repetitions  Int @default(8)
  weight_lbs   Int @default(45)
  // duration_set DurationSet?
  routine      Routine      @relation(fields: [routine_id], references: [id], onDelete: Cascade)
  routine_id   Int
}

model ScheduledSet {
  id           Int          @id @default(autoincrement())
  repetitions  Int 
  weight_lbs   Int 
  routine      ScheduledRoutine      @relation(fields: [routine_id], references: [id], onDelete: Cascade)
  routine_id   Int
  completed Boolean
  rpe Int?
}

// model DurationSet {
//   id             Int        @id @default(autoincrement())
//   duration       Int
//   default_set    DefaultSet @relation(fields: [default_set_id], references: [id])
//   default_set_id Int        @unique
// }

model Exercise {
  id                 Int                  @id @default(autoincrement())
  name               String               @db.VarChar(255)
  difficulty         Difficulty
  description        String
  video_path         String
  routines           Routine[]
  scheduled_routines           ScheduledRoutine[]
  muscles            Muscle[]
  tags               Tag[]                @relation("ExerciseToTag")
  embedding          Float[]
  type               String
  equipment          String
  log_search_results Float
  users              UserSavedExercises[]
}

model Tag {
  id        Int        @id @default(autoincrement())
  name      String     @db.VarChar(255)
  exercises Exercise[] @relation("ExerciseToTag")
  workouts  Workout[]
}

model Muscle {
  id          Int        @id @default(autoincrement())
  name        String     @db.VarChar(255)
  bodyPart_id Int
  bodyPart    BodyPart   @relation(fields: [bodyPart_id], references: [id], onDelete: Cascade)
  // workouts Workout[]
  exercises   Exercise[]
}

model BodyPart {
  id      Int      @id @default(autoincrement())
  name    String   @db.VarChar(255)
  muscles Muscle[]
}

enum Difficulty {
  beginner
  intermediate
  expert
}

enum RoutineType {
  default
  duration
}

enum CompletionStatus {
  scheduled
  inProgress
  complete
  incomplete //ended but did not complete
  skipped
}
